<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8">
    <title>BOLA COM MIRA 3D + BULLET PHYSICS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
        }
    </style>
</head>

<body>

    <div id="info">BY JOSEPH CLIMBER</div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // Parâmetros para controlar a posição do mesh miniGun
        let miniGunOffsetX = 0;
        let miniGunOffsetY = 0;
        let miniGunOffsetZ = 0;
        const canvas = document.createElement("canvas");
        canvas.style.width = "100vw";
        canvas.style.height = "100vh";
        document.body.appendChild(canvas);

        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.5, 0.8, 0.9, 1);

        new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene).intensity = 1.5;

        const RADIUS = 1;
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: RADIUS * 2, segments: 80 }, scene);
        sphere.position.set(0, RADIUS, 0);

        sphere.checkCollisions = true;
        sphere.ellipsoid = new BABYLON.Vector3(RADIUS, RADIUS, RADIUS);
        sphere.ellipsoidOffset = new BABYLON.Vector3(0, 0, 0);
        scene.collisionsEnabled = true;

        const mat = new BABYLON.StandardMaterial("mat", scene);
        mat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/earth.jpg", scene);
        sphere.material = mat;

        let MOVE_SPEED = 8;
        const TURN_SPEED_KEY = 2.5;
        const TURN_SPEED_MOUSE = 0.008;
        const JUMP_POWER = 8;
        const GRAVITY = -25;

        let velocityY = 0;
        let isGrounded = true;
        let mouseControl = false;

        let sphereVelocity = new BABYLON.Vector3(0, 0, 0);
        let maxSpeed = 10;
        const ACCELERATION = 0.3;
        const DECELERATION = 0.1;
        let currentSpeed = 0;
        let isShiftPressed = false;
        let isDeceleratingFromShift = false;

        let moveDir = 0;
        let aimDir = 0;
        let aimPitch = 0;
        const AIM_PITCH_LIMIT = Math.PI / 3;

        const keys = { w: false, a: false, s: false, d: false };

        const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const crosshair = new BABYLON.GUI.TextBlock();
        crosshair.text = "+";
        crosshair.color = "white";
        crosshair.fontSize = 40;
        gui.addControl(crosshair);

        canvas.addEventListener("click", () => {
            canvas.requestPointerLock();
            mouseControl = true;
        });
        document.addEventListener("pointerlockchange", () => {
            if (!document.pointerLockElement) mouseControl = false;
        });
        document.addEventListener("mousemove", e => {
            if (!mouseControl) return;
            aimDir += e.movementX * TURN_SPEED_MOUSE;
            aimPitch -= e.movementY * TURN_SPEED_MOUSE;
            aimPitch = Math.max(-AIM_PITCH_LIMIT, Math.min(AIM_PITCH_LIMIT, aimPitch));
        });

        window.addEventListener("keydown", e => {
            const k = e.key.toLowerCase();
            if ("wasd".includes(k)) keys[k] = true;
            if (k === " " && isGrounded) { velocityY = JUMP_POWER; isGrounded = false; }
            if (k === "c") cameraSwitched = !cameraSwitched;
            if (e.shiftKey && !isShiftPressed) {
                isShiftPressed = true;
                maxSpeed = 15;
                isDeceleratingFromShift = false;
            }
            // Lógica de pegar/largar armadura (modelo3D) com F
            if (k === "f" && modelo3D) {
                if (!armadura) {
                    // Só pega se estiver tocando
                    const distancia = BABYLON.Vector3.Distance(sphere.position, modelo3D.position);
                    if (distancia <= RADIUS + 0.5) {
                        armadura = true;
                        modelo3D.position.x = sphere.position.x;
                        modelo3D.position.y = sphere.position.y;
                        modelo3D.position.z = sphere.position.z;
                        modelo3D.setEnabled(true);
                    }
                } else {
                    // Se já está "vestido", larga ao pressionar F
                    armadura = false;
                    modelo3D.position.x = sphere.position.x;
                    modelo3D.position.y = 0.1;
                    modelo3D.position.z = sphere.position.z;
                    modelo3D.setEnabled(true);
                }
            }
        });
        window.addEventListener("keyup", e => {
            const k = e.key.toLowerCase();
            if ("wasd".includes(k)) keys[k] = false;
            if (!e.shiftKey && isShiftPressed) {
                isShiftPressed = false;
                maxSpeed = 10;
                if (currentSpeed > 10) isDeceleratingFromShift = true;
            }
        });

        const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 10, -15), scene);
        camera.inputs.clear();
        camera.minZ = 0.1;
        camera.maxZ = 5000;
        const camOffsetDefault = new BABYLON.Vector3(0, 3, 15); // camera padrão
        const camOffsetSwitch = new BABYLON.Vector3(-1, 1, 5); // camera alternativa
        let camRot = 0;
        let cameraSwitched = false;

        let modelo3D = null;
        let modelo3DAnimations = [];
        let miniGunOriginalOffset = null;
        let canoModular = null;
        let armadura = false; // Estado: está "vestindo" a armadura (modelo3D)

        /*adicione modelo ao mapa*/ /*[não altere isso]*/
        /*X -> lateral | Y -> altura | Z -> profundidade */

        /*
        BABYLON.SceneLoader.ImportMesh("", "scenario/", "cano_modular2.glb", scene, (meshes, particleSystems, skeletons,
            animationGroups) => {
            canoModular = meshes[0];
            canoModular.scaling.setAll(1);
            canoModular.position.set(5, 0, 50);
            // Colisão simples: ativa checkCollisions no mesh principal e todos os filhos
            canoModular.checkCollisions = true;
            canoModular.getChildMeshes().forEach(child => child.checkCollisions = true);
        });
        */


        BABYLON.SceneLoader.ImportMesh("", "models/", "first_skin.glb", scene, (meshes, particleSystems, skeletons, animationGroups) => {
            modelo3D = meshes[0];
            modelo3D.scaling.setAll(1); // <-- Ajusta o tamanho da modelo3D
            modelo3D.rotation = new BABYLON.Vector3(0, Math.PI, 0);
            // Centraliza pivô do modelo no centro da sphere
            const sphereCenter = sphere.getAbsolutePosition();
            const modelo3DCenter = modelo3D.getBoundingInfo().boundingBox.centerWorld;
            const offset = sphereCenter.subtract(modelo3DCenter);
            modelo3D.setPivotPoint(modelo3D.getPivotPoint().add(offset));


            // Remove miniGun da hierarquia do modelo3D e adiciona diretamente à cena
            /*#######################################################################*/

            const miniGunMesh = modelo3D.getChildMeshes().find(m => m.name === "miniGun");
            if (miniGunMesh) {
                miniGunOriginalOffset = miniGunMesh.position.clone(); // Salva offset local original
                miniGunMesh.parent = null;
                scene.addMesh(miniGunMesh);
                window.miniGunMesh = miniGunMesh; // para acesso global no render loop
            }
            // Armazena as animações e pausa elas
            modelo3DAnimations = animationGroups;
            modelo3DAnimations.forEach(anim => {
                anim.stop();
            });
        });

        const PROJECTILE_SPEED = 60;
        const BOUNCE_DAMPING = 0.1;
        const MAX_BOUNCES = 3;
        let isFiring = false;
        let cooldown = 0;
        const bullets = [];

        scene.onPointerObservable.add(e => {
            if (e.type === BABYLON.PointerEventTypes.POINTERDOWN && e.event.button === 0) isFiring = true;
            if (e.type === BABYLON.PointerEventTypes.POINTERUP && e.event.button === 0) isFiring = false;
        });

        function createBattleMap() {
            const blockMaterial = new BABYLON.StandardMaterial("blockMat", scene);
            blockMaterial.diffuseTexture = new BABYLON.Texture("texture/vigas.jpg", scene);
            blockMaterial.diffuseTexture.uScale = 2;
            blockMaterial.diffuseTexture.vScale = 2;

            const fenceMaterial = new BABYLON.StandardMaterial("fenceMat", scene);
            fenceMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);
            fenceMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            fenceMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            fenceMaterial.alpha = 0.6;
            fenceMaterial.alphaMode = BABYLON.Engine.ALPHA_COMBINE;

            const coverMaterial = new BABYLON.StandardMaterial("coverMat", scene);
            coverMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);


            const covers = [
                [-12, 8], [12, 8], [-12, -8], [12, -8],
                [-18, 0], [18, 0], [0, 15], [0, -15],
                [-8, 18], [8, -18], [-15, -15], [15, 15]
            ];

            covers.forEach(pos => {
                const cover = BABYLON.MeshBuilder.CreateBox("cover", { width: 2, height: 1, depth: 2 }, scene);
                cover.position.set(pos[0], 0.5, pos[1]);
                cover.material = coverMaterial;
                cover.checkCollisions = true;              // <-- importante
            });

            const buildings = [
                { pos: [-18, 2.5, -18], size: [4, 5, 4] },
                { pos: [18, 3, 18], size: [5, 6, 3] },
                { pos: [-20, 2, 15], size: [3, 4, 6] },
                { pos: [15, 2.5, -20], size: [6, 5, 4] },
                { pos: [5, 4, 5], size: [3, 8, 3] }
            ];

            buildings.forEach(b => {
                const building = BABYLON.MeshBuilder.CreateBox("building", {
                    width: b.size[0], height: b.size[1], depth: b.size[2]
                }, scene);
                building.position.set(b.pos[0], b.size[1] / 2, b.pos[2]);
                building.material = blockMaterial;
                building.checkCollisions = true;           // <-- importante
            });

            const platforms = [
                [-10, -6], [10, 6], [6, -10], [-6, 12]
            ];

            platforms.forEach(pos => {
                const platform = BABYLON.MeshBuilder.CreateBox("platform", { width: 4, height: 0.3, depth: 4 }, scene);
                platform.position.set(pos[0], 2.5, pos[1]);
                platform.material = coverMaterial;
                platform.checkCollisions = true;           // <-- importante

                const support = BABYLON.MeshBuilder.CreateBox("support", { width: 0.5, height: 2.5, depth: 0.5 }, scene);
                support.position.set(pos[0], 1.25, pos[1]);
                support.material = blockMaterial;
                support.checkCollisions = true;             // <-- importante
            });
        }

        createBattleMap();
        /*TAMANHO DO CHÃO*/
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 200, height: 200 }, scene);
        ground.position.y = 0;
        ground.material = new BABYLON.StandardMaterial("groundMat", scene);
        ground.material.diffuseTexture = new BABYLON.Texture("../texture/ciment_chao.jpg", scene);
        ground.material.diffuseTexture.uScale = 15;
        ground.material.diffuseTexture.vScale = 15;
        ground.checkCollisions = true;                     // <-- importante

        // Função para criar um cano de teste procedural
        function criarCanoTeste(scene) {
            // Cria um caminho reto para o tubo, base em y=0
            const comprimento = 6;
            const path = [
                new BABYLON.Vector3(0, 0, 20),
                new BABYLON.Vector3(0, comprimento, 20)
            ];
            // Tubo oco (parede do cano)
            const tubo = BABYLON.MeshBuilder.CreateTube("cano_teste_tubo", {
                path: path,
                radius: 2,
                tessellation: 32,
                cap: BABYLON.Mesh.NO_CAP
            }, scene);
            tubo.checkCollisions = true;
            tubo.material = new BABYLON.StandardMaterial("matTubo", scene);
            tubo.material.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
            tubo.rotation.x = Math.PI / 2;
            // Após rotação, o eixo Y vira Z. Ajusta para que a base fique no chão:
            tubo.position.y = 2; // raio do tubo
            tubo.position.z = 20; // mantém posição original
        }
        criarCanoTeste(scene);

        scene.onBeforeRenderObservable.add(() => {
            const dt = engine.getDeltaTime() / 1000;

            if (keys.a) moveDir -= TURN_SPEED_KEY * dt;
            if (keys.d) moveDir += TURN_SPEED_KEY * dt;

            const moveForward = new BABYLON.Vector3(Math.sin(moveDir), 0, Math.cos(moveDir));

            if (isDeceleratingFromShift && currentSpeed > 10) {
                currentSpeed = Math.max(currentSpeed - 1, 10);
                if (currentSpeed <= 10) isDeceleratingFromShift = false;
            }

            if (keys.w && !isDeceleratingFromShift) {
                currentSpeed = Math.min(currentSpeed + ACCELERATION, maxSpeed);
            } else if (keys.s) {
                if (currentSpeed <= 0) {
                    currentSpeed = Math.max(currentSpeed - ACCELERATION, -maxSpeed);
                } else {
                    currentSpeed = Math.max(currentSpeed - (DECELERATION + 0.2), 0);
                }
            } else {
                if (currentSpeed > 0) currentSpeed = Math.max(currentSpeed - DECELERATION, 0);
                else if (currentSpeed < 0) currentSpeed = Math.min(currentSpeed + DECELERATION, 0);
            }

            if (Math.abs(currentSpeed) > 0.01) {
                const direction = currentSpeed < 0 ? moveForward.scale(-1) : moveForward;
                const movement = direction.scale(Math.abs(currentSpeed) * dt);

                sphere.moveWithCollisions(movement);
                // ====================================================

                if (Math.abs(currentSpeed) > 0.1) {
                    sphere.rotation.x += (currentSpeed * dt) / RADIUS;
                }
            }

            sphere.rotation.y = moveDir;

            const aimForward = new BABYLON.Vector3(
                Math.sin(aimDir) * Math.cos(aimPitch),
                Math.sin(aimPitch),
                Math.cos(aimDir) * Math.cos(aimPitch)
            ).normalize();
            //
            const y0 = sphere.position.y + 1.4;
            const vx = aimForward.x * PROJECTILE_SPEED;
            const vy = aimForward.y * PROJECTILE_SPEED;
            const vz = aimForward.z * PROJECTILE_SPEED;
            const g = Math.abs(GRAVITY);
            const tHit = (vy + Math.sqrt(vy * vy + 2 * g * y0)) / g;
            const hitX = sphere.position.x + vx * tHit;
            const hitZ = sphere.position.z + vz * tHit;
            //
            const proj = BABYLON.Vector3.Project(
                new BABYLON.Vector3(hitX, 0, hitZ),
                BABYLON.Matrix.Identity(),
                scene.getTransformMatrix(),
                camera.viewport.toGlobal(engine)
            );
            // Ajusta posição do crosshair na tela
            crosshair.left = proj.x - engine.getRenderWidth() / 2;
            crosshair.top = proj.y - engine.getRenderHeight() / 2;
            // Ajusta posição da modelo3D em relação à sphere
            const rightOffset = new BABYLON.Vector3(
                Math.cos(aimDir) *
                (RADIUS + 0.04), // <-- ajuste lateral
                0.5,                               // <-- ajuste vertical
                -Math.sin(aimDir) * (RADIUS + 0.5) // <-- ajuste profundidade
            );



            /*########## POSIÇÃO DA CABEÇA EM RELAÇÃO A SPHERE ###########*/
            if (modelo3D) {
                if (armadura) {
                    // Se está "vestindo" a armadura, gruda na sphere
                    modelo3D.position.x = sphere.position.x;
                    modelo3D.position.z = sphere.position.z;
                    modelo3D.position.y = sphere.position.y;
                    // ROTAÇÃO — virado 90° para a direita (anti-horário) da direção de movimento
                    const angle = Math.atan2(rightOffset.x, rightOffset.z);
                    modelo3D.rotation.y = angle - Math.PI / 2;
                }
                // Se não está "vestindo", modelo3D fica parado onde foi largado
            }




            // Atualiza miniGunMesh para manter posição original do modelo3D, fora da hierarquia, acompanhando a esfera
            if (window.miniGunMesh && modelo3D && miniGunOriginalOffset) {
                // Aplica rotação Y do modelo3D ao offset do miniGun
                const rotMatrix = BABYLON.Matrix.RotationY(modelo3D.rotation.y);
                const offsetRotated = BABYLON.Vector3.TransformCoordinates(miniGunOriginalOffset, rotMatrix);
                const miniGunPos = modelo3D.position.add(offsetRotated);
                window.miniGunMesh.position.copyFrom(miniGunPos);
                // Sincroniza rotação Y do mesh miniGun com o modelo3D
                window.miniGunMesh.rotation.y = modelo3D.rotation.y;
                // Faz o miniGun sempre apontar para a direção do crosshair
                const lookPoint = miniGunPos.add(aimForward.scale(10));
                window.miniGunMesh.lookAt(lookPoint);
            }



            // Aplica gravidade com moveWithCollisions
            velocityY += GRAVITY * dt;
            const verticalMovement = new BABYLON.Vector3(0, velocityY * dt, 0);
            sphere.moveWithCollisions(verticalMovement);

            // Verifica se está no chão com raycast partindo do centro da esfera
            const rayDown = new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0, -1, 0), RADIUS + 0.15);
            const hit = scene.pickWithRay(rayDown, mesh => mesh !== sphere && mesh !== modelo3D && !mesh.name.includes("bullet"));

            if (hit.hit && hit.distance <= RADIUS + 0.02) {
                isGrounded = true;
                if (velocityY < 0) {
                    velocityY = 0;
                }
            } else {
                isGrounded = false;
            }

            // Só lança o bullet se o modelo3D estiver "vestido" (armadura = true)
            cooldown -= dt;
            if (isFiring && cooldown <= 0 && armadura) {
                cooldown = 0.07;
                // Calcula posição de spawn do bullet normalmente
                const rightOffset = new BABYLON.Vector3(
                    Math.cos(aimDir) * (RADIUS + 0.02),
                    1,
                    -Math.sin(aimDir) * (RADIUS + 0.02)
                );
                const spawn = sphere.position.add(rightOffset);
                const b = BABYLON.MeshBuilder.CreateSphere("bullet", { diameter: 0.12 }, scene);
                b.position.copyFrom(spawn);
                b.material = new BABYLON.StandardMaterial("", scene);
                b.material.emissiveColor = new BABYLON.Color3(1, 0.9, 0.3);
                bullets.push({ m: b, v: aimForward.scale(PROJECTILE_SPEED), t: 0, bounces: 0 });
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bu = bullets[i];
                bu.v.y += GRAVITY * 0.5 * dt;

                const velocity = bu.v.scale(dt);
                const ray = new BABYLON.Ray(bu.m.position, velocity.normalize(), velocity.length());
                const hit = scene.pickWithRay(ray, mesh => mesh !== sphere && mesh !== modelo3D && !mesh.name.includes("bullet"));

                if (hit.hit) {
                    if (bu.bounces < MAX_BOUNCES) {
                        const normal = hit.getNormal(true);
                        const reflected = bu.v.subtract(normal.scale(2 * BABYLON.Vector3.Dot(bu.v, normal)));
                        bu.v = reflected.scale(BOUNCE_DAMPING);
                        bu.bounces++;
                        bu.m.position.addInPlace(normal.scale(0.1));
                    } else {
                        bu.m.dispose();
                        bullets.splice(i, 1);
                    }
                } else {
                    bu.m.position.addInPlace(velocity);
                    bu.t += dt;

                    if (bu.m.position.y <= 0) {
                        if (bu.bounces < MAX_BOUNCES) {
                            bu.v.y = Math.abs(bu.v.y) * BOUNCE_DAMPING;
                            bu.m.position.y = 0.1;
                            bu.bounces++;
                        } else {
                            bu.m.dispose();
                            bullets.splice(i, 1);
                        }
                    } else if (bu.t > 5) {
                        bu.m.dispose();
                        bullets.splice(i, 1);
                    }
                }
            }

            const camOffset = cameraSwitched ? camOffsetSwitch : camOffsetDefault;

            camRot = BABYLON.Scalar.Lerp(camRot, aimDir + Math.PI, 0.1);
            const offset = BABYLON.Vector3.TransformCoordinates(camOffset, BABYLON.Matrix.RotationY(camRot));
            const target = sphere.position.clone().add(offset);
            camera.position = BABYLON.Vector3.Lerp(camera.position, target, 0.1);

            const camTarget = sphere.position.clone().add(
                new BABYLON.Vector3(
                    Math.sin(aimDir) * Math.cos(aimPitch),
                    Math.sin(aimPitch) + 1.2,
                    Math.cos(aimDir) * Math.cos(aimPitch)
                )
            );
            camera.setTarget(camTarget);
        });

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>

</body>

</html>