<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="utf-8">
    <title>BOLA COM MIRA 3D + BULLET PHYSICS</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
        }
    </style>
</head>

<body>

    <div id="info">BY JOSEPH CLIMBER</div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
        // Parâmetros para controlar a posição do mesh miniGun
        let miniGunOffsetX = 0;
        let miniGunOffsetY = 0;
        let miniGunOffsetZ = 0;
        const canvas = document.createElement("canvas");
        canvas.style.width = "100vw";
        canvas.style.height = "100vh";
        document.body.appendChild(canvas);

        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.5, 0.8, 0.9, 1);

        new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene).intensity = 1.5;

        const RADIUS = 1;
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: RADIUS * 2, segments: 80 }, scene);
        sphere.position.set(0, RADIUS, 0);

        sphere.checkCollisions = true;
        sphere.ellipsoid = new BABYLON.Vector3(RADIUS, RADIUS, RADIUS);
        sphere.ellipsoidOffset = new BABYLON.Vector3(0, 0, 0);
        scene.collisionsEnabled = true;

        const mat = new BABYLON.StandardMaterial("mat", scene);
        mat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/earth.jpg", scene);
        sphere.material = mat;

        let MOVE_SPEED = 8;
        const TURN_SPEED_KEY = 2.5;
        const TURN_SPEED_MOUSE = 0.008;
        const JUMP_POWER = 8;
        const GRAVITY = -25;

        let velocityY = 0;
        let isGrounded = true;
        let mouseControl = false;

        let sphereVelocity = new BABYLON.Vector3(0, 0, 0);
        let maxSpeed = 10;
        const ACCELERATION = 0.3;
        const DECELERATION = 0.1;
        let currentSpeed = 0;
        let isShiftPressed = false;
        let isDeceleratingFromShift = false;

        let moveDir = 0;
        let aimDir = 0;
        let aimPitch = 0;
        const AIM_PITCH_LIMIT = Math.PI / 3;

        const keys = { w: false, a: false, s: false, d: false };

        const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        const crosshair = new BABYLON.GUI.TextBlock();
        crosshair.text = "+";
        crosshair.color = "white";
        crosshair.fontSize = 40;
        gui.addControl(crosshair);

        canvas.addEventListener("click", () => {
            canvas.requestPointerLock();
            mouseControl = true;
        });
        document.addEventListener("pointerlockchange", () => {
            if (!document.pointerLockElement) mouseControl = false;
        });
        document.addEventListener("mousemove", e => {
            if (!mouseControl) return;
            aimDir += e.movementX * TURN_SPEED_MOUSE;
            aimPitch -= e.movementY * TURN_SPEED_MOUSE;
            aimPitch = Math.max(-AIM_PITCH_LIMIT, Math.min(AIM_PITCH_LIMIT, aimPitch));
        });

        window.addEventListener("keydown", e => {
            const k = e.key.toLowerCase();
            if ("wasd".includes(k)) keys[k] = true;
            // Corrige detecção de chão para terrenos irregulares
            if (k === " " && isGrounded) {
                // Raycast para detectar altura do terreno abaixo da sphere
                const rayDown = new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0, -1, 0), RADIUS + 2);
                const hit = scene.pickWithRay(rayDown, mesh => mesh.name === "terrenoVerde");
                let alturaChao = 0;
                if (hit.hit) {
                    alturaChao = hit.pickedPoint.y;
                }
                // Só permite pular se estiver realmente próximo do terreno
                if (Math.abs(sphere.position.y - alturaChao) <= RADIUS + 0.2) {
                    velocityY = JUMP_POWER;
                    isGrounded = false;
                }
            }
            if (k === "c") cameraSwitched = !cameraSwitched;
            if (e.shiftKey && !isShiftPressed) {
                isShiftPressed = true;
                maxSpeed = 15;
                isDeceleratingFromShift = false;
            }
            // Lógica de pegar/largar armadura (modelo3D) com F
            if (k === "f" && modelo3D) {
                if (!armadura) {
                    // Só pega se estiver tocando
                    const distancia = BABYLON.Vector3.Distance(sphere.position, modelo3D.position);
                    if (distancia <= RADIUS + 0.5) {
                        armadura = true;
                        // Centraliza pelo centro do bounding box
                        const centroModelo = modelo3D.getBoundingInfo().boundingBox.centerWorld;
                        const offset = sphere.position.subtract(centroModelo);
                        modelo3D.position.addInPlace(offset);
                        modelo3D.setEnabled(true);
                    }
                } else {
                    // Se já está "vestido", larga ao pressionar F
                    armadura = false;
                    modelo3D.position.x = sphere.position.x;
                    // Mantém a posição Y atual do modelo3D
                    // modelo3D.position.y = 0.1; // Removido!
                    modelo3D.position.z = sphere.position.z;
                    modelo3D.setEnabled(true);
                }
            }
        });
        window.addEventListener("keyup", e => {
            const k = e.key.toLowerCase();
            if ("wasd".includes(k)) keys[k] = false;
            if (!e.shiftKey && isShiftPressed) {
                isShiftPressed = false;
                maxSpeed = 10;
                if (currentSpeed > 10) isDeceleratingFromShift = true;
            }
        });

        const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 10, -15), scene);
        camera.inputs.clear();
        camera.minZ = 0.1;
        camera.maxZ = 5000;
        const camOffsetDefault = new BABYLON.Vector3(0, 3, 15); // camera padrão
        const camOffsetSwitch = new BABYLON.Vector3(-1, 1, 5); // camera alternativa
        let camRot = 0;
        let cameraSwitched = false;

        let modelo3D = null;
        let modelo3DAnimations = [];
        let miniGunOriginalOffset = null;
        let armadura = false; // Estado: está "vestindo" a armadura (modelo3D)

        /*adicione modelo ao mapa*/ /*[não altere isso]*/
        /*X -> lateral | Y -> altura | Z -> profundidade */
        BABYLON.SceneLoader.ImportMesh("", "models/", "first_skin.glb", scene, (meshes, particleSystems, skeletons, animationGroups) => {
            modelo3D = meshes[0];
            modelo3D.scaling.setAll(1); // <-- Ajusta o tamanho da modelo3D
            modelo3D.rotation = new BABYLON.Vector3(0, Math.PI, 0);
            // Centraliza pivô do modelo no centro da sphere
            const sphereCenter = sphere.getAbsolutePosition();
            const modelo3DCenter = modelo3D.getBoundingInfo().boundingBox.centerWorld;
            const offset = sphereCenter.subtract(modelo3DCenter);
            modelo3D.setPivotPoint(modelo3D.getPivotPoint().add(offset));


            // Remove miniGun da hierarquia do modelo3D e adiciona diretamente à cena
            /*#######################################################################*/

            const miniGunMesh = modelo3D.getChildMeshes().find(m => m.name === "miniGun");
            if (miniGunMesh) {
                miniGunOriginalOffset = miniGunMesh.position.clone(); // Salva offset local original
                miniGunMesh.parent = null;
                scene.addMesh(miniGunMesh);
                window.miniGunMesh = miniGunMesh; // para acesso global no render loop
            }
            // Armazena as animações e pausa elas
            modelo3DAnimations = animationGroups;
            modelo3DAnimations.forEach(anim => {
                anim.stop();
            });
        });

        const PROJECTILE_SPEED = 60;
        const BOUNCE_DAMPING = 0.1;
        const MAX_BOUNCES = 3;
        let isFiring = false;
        let cooldown = 0;
        const bullets = [];

        scene.onPointerObservable.add(e => {
            if (e.type === BABYLON.PointerEventTypes.POINTERDOWN && e.event.button === 0) isFiring = true;
            if (e.type === BABYLON.PointerEventTypes.POINTERUP && e.event.button === 0) isFiring = false;
        });

        // Cria um terreno procedural verde com leves relevos
        function criarTerrenoVerde(scene) {
            const largura = 200;
            const profundidade = 200;
            const subdivisoes = 100;
            // Gera altura procedural simples (Perlin-like)
            function altura(x, z) {
                return 2 * Math.sin(x / 20) * Math.cos(z / 25) + 1.2 * Math.sin(z / 15);
            }
            const vertexData = BABYLON.VertexData.CreateGround({
                width: largura,
                height: profundidade,
                subdivisions: subdivisoes
            });
            // Gradiente marrom claro/escuro
            const cores = [];
            for (let i = 0; i < vertexData.positions.length; i += 3) {
                const x = vertexData.positions[i];
                const z = vertexData.positions[i + 2];
                const y = altura(x, z);
                vertexData.positions[i + 1] = y;
                const t = (y + 4) / 8;
                const r = 0.35 + (0.82 - 0.35) * t;
                const g = 0.24 + (0.71 - 0.24) * t;
                const b = 0.16 + (0.55 - 0.16) * t;
                cores.push(r, g, b, 1);
            }
            vertexData.colors = cores;
            const terreno = new BABYLON.Mesh("terrenoVerde", scene);
            vertexData.applyToMesh(terreno);
            terreno.position.y = 0;
            terreno.checkCollisions = true;
            // Material com textura de cimento e vertex color
            const matCimento = new BABYLON.StandardMaterial("matCimento", scene);
            matCimento.diffuseTexture = new BABYLON.Texture("../texture/ciment_chao.jpg", scene);
            matCimento.diffuseTexture.uScale = 15;
            matCimento.diffuseTexture.vScale = 15;
            matCimento.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            matCimento.vertexColorEnabled = true;
            terreno.material = matCimento;
            // Sombra
            const luzDirecional = new BABYLON.DirectionalLight("dirLight", new BABYLON.Vector3(-0.5, -1, -0.5), scene);
            luzDirecional.position = new BABYLON.Vector3(50, 80, 50);
            luzDirecional.intensity = 0.7;
            const sombra = new BABYLON.ShadowGenerator(2048, luzDirecional);
            sombra.addShadowCaster(terreno);
            terreno.receiveShadows = true;
        }
        criarTerrenoVerde(scene);

        scene.onBeforeRenderObservable.add(() => {
            const dt = engine.getDeltaTime() / 1000;

            if (keys.a) moveDir -= TURN_SPEED_KEY * dt;
            if (keys.d) moveDir += TURN_SPEED_KEY * dt;

            const moveForward = new BABYLON.Vector3(Math.sin(moveDir), 0, Math.cos(moveDir));

            if (isDeceleratingFromShift && currentSpeed > 10) {
                currentSpeed = Math.max(currentSpeed - 1, 10);
                if (currentSpeed <= 10) isDeceleratingFromShift = false;
            }

            if (keys.w && !isDeceleratingFromShift) {
                currentSpeed = Math.min(currentSpeed + ACCELERATION, maxSpeed);
            } else if (keys.s) {
                if (currentSpeed <= 0) {
                    currentSpeed = Math.max(currentSpeed - ACCELERATION, -maxSpeed);
                } else {
                    currentSpeed = Math.max(currentSpeed - (DECELERATION + 0.2), 0);
                }
            } else {
                if (currentSpeed > 0) currentSpeed = Math.max(currentSpeed - DECELERATION, 0);
                else if (currentSpeed < 0) currentSpeed = Math.min(currentSpeed + DECELERATION, 0);
            }

            if (Math.abs(currentSpeed) > 0.01) {
                const direction = currentSpeed < 0 ? moveForward.scale(-1) : moveForward;
                const movement = direction.scale(Math.abs(currentSpeed) * dt);

                sphere.moveWithCollisions(movement);
                // ====================================================

                if (Math.abs(currentSpeed) > 0.1) {
                    sphere.rotation.x += (currentSpeed * dt) / RADIUS;
                }
            }

            sphere.rotation.y = moveDir;

            const aimForward = new BABYLON.Vector3(
                Math.sin(aimDir) * Math.cos(aimPitch),
                Math.sin(aimPitch),
                Math.cos(aimDir) * Math.cos(aimPitch)
            ).normalize();
            //
            const y0 = sphere.position.y + 1.4;
            const vx = aimForward.x * PROJECTILE_SPEED;
            const vy = aimForward.y * PROJECTILE_SPEED;
            const vz = aimForward.z * PROJECTILE_SPEED;
            const g = Math.abs(GRAVITY);
            const tHit = (vy + Math.sqrt(vy * vy + 2 * g * y0)) / g;
            const hitX = sphere.position.x + vx * tHit;
            const hitZ = sphere.position.z + vz * tHit;
            //
            const proj = BABYLON.Vector3.Project(
                new BABYLON.Vector3(hitX, 0, hitZ),
                BABYLON.Matrix.Identity(),
                scene.getTransformMatrix(),
                camera.viewport.toGlobal(engine)
            );
            // Ajusta posição do crosshair na tela
            crosshair.left = proj.x - engine.getRenderWidth() / 2;
            crosshair.top = proj.y - engine.getRenderHeight() / 2;
            // Ajusta posição da modelo3D em relação à sphere
            const rightOffset = new BABYLON.Vector3(
                Math.cos(aimDir) *
                (RADIUS + 0.04), // <-- ajuste lateral
                0.5,                               // <-- ajuste vertical
                -Math.sin(aimDir) * (RADIUS + 0.5) // <-- ajuste profundidade
            );



            /*########## POSIÇÃO DA CABEÇA EM RELAÇÃO A SPHERE ###########*/
            if (modelo3D) {
                if (armadura) {
                    // Se está "vestindo" a armadura, gruda na sphere
                    modelo3D.position.x = sphere.position.x;
                    modelo3D.position.z = sphere.position.z;
                    modelo3D.position.y = sphere.position.y;
                    // ROTAÇÃO — virado 90° para a direita (anti-horário) da direção de movimento
                    const angle = Math.atan2(rightOffset.x, rightOffset.z);
                    modelo3D.rotation.y = angle - Math.PI / 2;
                }
                // Se não está "vestindo", modelo3D fica parado onde foi largado
            }




            // Atualiza miniGunMesh para manter posição original do modelo3D, fora da hierarquia, acompanhando a esfera
            if (window.miniGunMesh && modelo3D && miniGunOriginalOffset) {
                // Aplica rotação Y do modelo3D ao offset do miniGun
                const rotMatrix = BABYLON.Matrix.RotationY(modelo3D.rotation.y);
                const offsetRotated = BABYLON.Vector3.TransformCoordinates(miniGunOriginalOffset, rotMatrix);
                const miniGunPos = modelo3D.position.add(offsetRotated);
                window.miniGunMesh.position.copyFrom(miniGunPos);
                // Sincroniza rotação Y do mesh miniGun com o modelo3D
                window.miniGunMesh.rotation.y = modelo3D.rotation.y;
                // Faz o miniGun sempre apontar para a direção do crosshair
                const lookPoint = miniGunPos.add(aimForward.scale(10));
                window.miniGunMesh.lookAt(lookPoint);
            }



            // Aplica gravidade com moveWithCollisions
            velocityY += GRAVITY * dt;
            const verticalMovement = new BABYLON.Vector3(0, velocityY * dt, 0);
            sphere.moveWithCollisions(verticalMovement);

            // Verifica se está no chão com raycast partindo do centro da esfera
            const rayDown = new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0, -1, 0), RADIUS + 0.15);
            const hit = scene.pickWithRay(rayDown, mesh => mesh !== sphere && mesh !== modelo3D && !mesh.name.includes("bullet"));

            if (hit.hit && hit.distance <= RADIUS + 0.02) {
                isGrounded = true;
                if (velocityY < 0) {
                    velocityY = 0;
                }
            } else {
                isGrounded = false;
            }

            // Só lança o bullet se o modelo3D estiver "vestido" (armadura = true)
            cooldown -= dt;
            if (isFiring && cooldown <= 0 && armadura) {
                cooldown = 0.07;
                // Calcula posição de spawn do bullet normalmente
                const rightOffset = new BABYLON.Vector3(
                    Math.cos(aimDir) * (RADIUS + 0.02),
                    1,
                    -Math.sin(aimDir) * (RADIUS + 0.02)
                );
                const spawn = sphere.position.add(rightOffset);
                const b = BABYLON.MeshBuilder.CreateSphere("bullet", { diameter: 0.12 }, scene);
                b.position.copyFrom(spawn);
                b.material = new BABYLON.StandardMaterial("", scene);
                b.material.emissiveColor = new BABYLON.Color3(1, 0.9, 0.3);
                bullets.push({ m: b, v: aimForward.scale(PROJECTILE_SPEED), t: 0, bounces: 0 });
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const bu = bullets[i];
                bu.v.y += GRAVITY * 0.5 * dt;

                const velocity = bu.v.scale(dt);
                const ray = new BABYLON.Ray(bu.m.position, velocity.normalize(), velocity.length());
                const hit = scene.pickWithRay(ray, mesh => mesh !== sphere && mesh !== modelo3D && !mesh.name.includes("bullet"));

                if (hit.hit) {
                    if (bu.bounces < MAX_BOUNCES) {
                        const normal = hit.getNormal(true);
                        const reflected = bu.v.subtract(normal.scale(2 * BABYLON.Vector3.Dot(bu.v, normal)));
                        bu.v = reflected.scale(BOUNCE_DAMPING);
                        bu.bounces++;
                        bu.m.position.addInPlace(normal.scale(0.1));
                    } else {
                        bu.m.dispose();
                        bullets.splice(i, 1);
                    }
                } else {
                    bu.m.position.addInPlace(velocity);
                    bu.t += dt;

                    if (bu.m.position.y <= 0) {
                        if (bu.bounces < MAX_BOUNCES) {
                            bu.v.y = Math.abs(bu.v.y) * BOUNCE_DAMPING;
                            bu.m.position.y = 0.1;
                            bu.bounces++;
                        } else {
                            bu.m.dispose();
                            bullets.splice(i, 1);
                        }
                    } else if (bu.t > 5) {
                        bu.m.dispose();
                        bullets.splice(i, 1);
                    }
                }
            }

            const camOffset = cameraSwitched ? camOffsetSwitch : camOffsetDefault;

            camRot = BABYLON.Scalar.Lerp(camRot, aimDir + Math.PI, 0.1);
            const offset = BABYLON.Vector3.TransformCoordinates(camOffset, BABYLON.Matrix.RotationY(camRot));
            const target = sphere.position.clone().add(offset);
            camera.position = BABYLON.Vector3.Lerp(camera.position, target, 0.1);

            const camTarget = sphere.position.clone().add(
                new BABYLON.Vector3(
                    Math.sin(aimDir) * Math.cos(aimPitch),
                    Math.sin(aimPitch) + 1.2,
                    Math.cos(aimDir) * Math.cos(aimPitch)
                )
            );
            camera.setTarget(camTarget);
        });

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
    </script>

</body>

</html>