<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <title>BOLA COM MIRA 3D + BULLET PHYSICS</title>
    <style>
        body { margin:0; overflow:hidden; background:#111; cursor: crosshair; }
        canvas { display:block; }
        #info { position:absolute; top:10px; left:10px; color:white; font-family:Arial; background:rgba(0,0,0,0.5); padding:10px; border-radius:8px;}
    </style>
</head>
<body>

<div id="info">Clique na tela → mouse para mirar<br>W/S = andar • A/D = virar • Clique = atirar • C = alternar câmera • Shift = correr • Espaço = pular</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
// Parâmetros para controlar a posição do mesh miniGun
let miniGunOffsetX = 0;
let miniGunOffsetY = 0;
let miniGunOffsetZ = 0;
const canvas = document.createElement("canvas");
canvas.style.width = "100vw";
canvas.style.height = "100vh";
document.body.appendChild(canvas);

const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.5, 0.8, 0.9, 1);

new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene).intensity = 1.5;

const RADIUS = 1;
const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: RADIUS*2, segments: 80 }, scene);
sphere.position.set(0, RADIUS, 0);

sphere.checkCollisions = true;
sphere.ellipsoid = new BABYLON.Vector3(RADIUS, RADIUS, RADIUS);
sphere.ellipsoidOffset = new BABYLON.Vector3(0, 0, 0);
scene.collisionsEnabled = true;

const mat = new BABYLON.StandardMaterial("mat", scene);
mat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/earth.jpg", scene);
sphere.material = mat;

let MOVE_SPEED = 8;
const TURN_SPEED_KEY = 2.5;
const TURN_SPEED_MOUSE = 0.008;
const JUMP_POWER = 8;
const GRAVITY = -25;

let velocityY = 0;
let isGrounded = true;
let mouseControl = false;

let sphereVelocity = new BABYLON.Vector3(0, 0, 0);
let maxSpeed = 10;
const ACCELERATION = 0.3;
const DECELERATION = 0.1;
let currentSpeed = 0;
let isShiftPressed = false;
let isDeceleratingFromShift = false;

let moveDir = 0;
let aimDir  = 0;
let aimPitch = 0;
const AIM_PITCH_LIMIT = Math.PI/3;

const keys = { w:false, a:false, s:false, d:false };

const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
const crosshair = new BABYLON.GUI.TextBlock();
crosshair.text = "+";
crosshair.color = "white";
crosshair.fontSize = 40;
gui.addControl(crosshair);

canvas.addEventListener("click", () => {
    canvas.requestPointerLock();
    mouseControl = true;
});
document.addEventListener("pointerlockchange", () => {
    if (!document.pointerLockElement) mouseControl = false;
});
document.addEventListener("mousemove", e => {
    if (!mouseControl) return;
    aimDir   += e.movementX * TURN_SPEED_MOUSE;
    aimPitch -= e.movementY * TURN_SPEED_MOUSE;
    aimPitch = Math.max(-AIM_PITCH_LIMIT, Math.min(AIM_PITCH_LIMIT, aimPitch));
});

window.addEventListener("keydown", e => {
    const k = e.key.toLowerCase();
    if ("wasd".includes(k)) keys[k] = true;
    if (k === " " && isGrounded) { velocityY = JUMP_POWER; isGrounded = false; }
    if (k === "c") cameraSwitched = !cameraSwitched;
    if (e.shiftKey && !isShiftPressed) {
        isShiftPressed = true;
        maxSpeed = 15;
        isDeceleratingFromShift = false;
    }
});
window.addEventListener("keyup", e => {
    const k = e.key.toLowerCase();
    if ("wasd".includes(k)) keys[k] = false;
    if (!e.shiftKey && isShiftPressed) {
        isShiftPressed = false;
        maxSpeed = 10;
        if (currentSpeed > 10) isDeceleratingFromShift = true;
    }
});

const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 10, -15), scene);
camera.inputs.clear();
camera.minZ = 0.1;
camera.maxZ = 5000;
const camOffsetDefault = new BABYLON.Vector3(0, 3, 15);
const camOffsetSwitch  = new BABYLON.Vector3(-1, 1, 5);
let camRot = 0;
let cameraSwitched = false;

let modelo3D = null;
let modelo3DAnimations = [];
BABYLON.SceneLoader.ImportMesh("", "models/", "first_skin.glb", scene, (meshes, particleSystems, skeletons, animationGroups) => {
    modelo3D = meshes[0];
    modelo3D.scaling.setAll(1); // <-- Ajusta o tamanho da modelo3D
    modelo3D.rotation = new BABYLON.Vector3(0, Math.PI, 0);
    // Centraliza pivô do modelo no centro da sphere
    const sphereCenter = sphere.getAbsolutePosition();
    const modelo3DCenter = modelo3D.getBoundingInfo().boundingBox.centerWorld;
    const offset = sphereCenter.subtract(modelo3DCenter);
    modelo3D.setPivotPoint(modelo3D.getPivotPoint().add(offset));


    // Remove miniGun da hierarquia do modelo3D e adiciona diretamente à cena
    /*#######################################################################*/

    const miniGunMesh = modelo3D.getChildMeshes().find(m => m.name === "miniGun");
    miniGunMesh.position = new BABYLON.Vector3(0, 3, 0); // Reseta posição relativa
    if (miniGunMesh) {
        miniGunMesh.parent = null;
        scene.addMesh(miniGunMesh);
        window.miniGunMesh = miniGunMesh; // para acesso global no render loop
    }
    // Armazena as animações e pausa elas
    modelo3DAnimations = animationGroups;
    modelo3DAnimations.forEach(anim => {
        anim.stop();
    });
});

const PROJECTILE_SPEED = 60;
const BOUNCE_DAMPING = 0.1;
const MAX_BOUNCES = 3;
let isFiring = false;
let cooldown = 0;
const bullets = [];

scene.onPointerObservable.add(e => {
    if (e.type === BABYLON.PointerEventTypes.POINTERDOWN && e.event.button === 0) isFiring = true;
    if (e.type === BABYLON.PointerEventTypes.POINTERUP   && e.event.button === 0) isFiring = false;
});

function createBattleMap() {
    const blockMaterial = new BABYLON.StandardMaterial("blockMat", scene);
    blockMaterial.diffuseTexture = new BABYLON.Texture("texture/vigas.jpg", scene);
    blockMaterial.diffuseTexture.uScale = 2;
    blockMaterial.diffuseTexture.vScale = 2;
    
    const fenceMaterial = new BABYLON.StandardMaterial("fenceMat", scene);
    fenceMaterial.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.35);
    fenceMaterial.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    fenceMaterial.emissiveColor = new BABYLON.Color3(0.05, 0.05, 0.05);
    fenceMaterial.alpha = 0.6;
    fenceMaterial.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
    
    const coverMaterial = new BABYLON.StandardMaterial("coverMat", scene);
    coverMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2);
    
    const walls = [
        { pos: [0, 1.5, -30], size: [60, 3, 0.2] },
        { pos: [0, 1.5, 30], size: [60, 3, 0.2] },
        { pos: [-30, 1.5, 0], size: [0.2, 3, 60] },
        { pos: [30, 1.5, 0], size: [0.2, 3, 60] }
    ];
    
    walls.forEach(w => {
        const fence = BABYLON.MeshBuilder.CreatePlane("fence", { 
            width: w.size[0] > 1 ? w.size[0] : w.size[2], 
            height: w.size[1] 
        }, scene);
        fence.position.set(w.pos[0], w.pos[1], w.pos[2]);
        
        // Rotaciona para ficar vertical e na direção correta
        if (w.size[0] > 1) {
            fence.rotation.y = 0;
        } else {
            fence.rotation.y = Math.PI / 2;
        }
        
        fence.material = fenceMaterial;
        fence.checkCollisions = true;
        
        // Cria barras verticais da grade
        const barCount = Math.floor((w.size[0] > 1 ? w.size[0] : w.size[2]) / 2);
        for (let i = 0; i < barCount; i++) {
            const bar = BABYLON.MeshBuilder.CreateBox("bar", { 
                width: 0.1, 
                height: w.size[1], 
                depth: 0.1 
            }, scene);
            
            if (w.size[0] > 1) {
                bar.position.set(
                    w.pos[0] - (w.size[0] / 2) + (i * 2) + 1,
                    w.pos[1],
                    w.pos[2]
                );
            } else {
                bar.position.set(
                    w.pos[0],
                    w.pos[1],
                    w.pos[2] - (w.size[2] / 2) + (i * 2) + 1
                );
            }
            
            bar.material = fenceMaterial;
            bar.checkCollisions = true;
        }
        
        // Barras horizontais
        const hBar1 = BABYLON.MeshBuilder.CreateBox("hbar", { 
            width: w.size[0] > 1 ? w.size[0] : 0.1, 
            height: 0.1, 
            depth: w.size[0] > 1 ? 0.1 : w.size[2] 
        }, scene);
        hBar1.position.set(w.pos[0], w.pos[1] + 1, w.pos[2]);
        hBar1.material = fenceMaterial;
        hBar1.checkCollisions = true;
        
        const hBar2 = BABYLON.MeshBuilder.CreateBox("hbar", { 
            width: w.size[0] > 1 ? w.size[0] : 0.1, 
            height: 0.1, 
            depth: w.size[0] > 1 ? 0.1 : w.size[2] 
        }, scene);
        hBar2.position.set(w.pos[0], w.pos[1] - 1, w.pos[2]);
        hBar2.material = fenceMaterial;
        hBar2.checkCollisions = true;
    });
    
    const covers = [
        [-12, 8], [12, 8], [-12, -8], [12, -8],
        [-18, 0], [18, 0], [0, 15], [0, -15],
        [-8, 18], [8, -18], [-15, -15], [15, 15]
    ];
    
    covers.forEach(pos => {
        const cover = BABYLON.MeshBuilder.CreateBox("cover", { width: 2, height: 1, depth: 2 }, scene);
        cover.position.set(pos[0], 0.5, pos[1]);
        cover.material = coverMaterial;
        cover.checkCollisions = true;              // <-- importante
    });
    
    const buildings = [
        { pos: [-18, 2.5, -18], size: [4, 5, 4] },
        { pos: [18, 3, 18], size: [5, 6, 3] },
        { pos: [-20, 2, 15], size: [3, 4, 6] },
        { pos: [15, 2.5, -20], size: [6, 5, 4] },
        { pos: [5, 4, 5], size: [3, 8, 3] }
    ];
    
    buildings.forEach(b => {
        const building = BABYLON.MeshBuilder.CreateBox("building", {
            width: b.size[0], height: b.size[1], depth: b.size[2]
        }, scene);
        building.position.set(b.pos[0], b.size[1]/2, b.pos[2]);
        building.material = blockMaterial;
        building.checkCollisions = true;           // <-- importante
    });
    
    const platforms = [
        [-10, -6], [10, 6], [6, -10], [-6, 12]
    ];
    
    platforms.forEach(pos => {
        const platform = BABYLON.MeshBuilder.CreateBox("platform", { width: 4, height: 0.3, depth: 4 }, scene);
        platform.position.set(pos[0], 2.5, pos[1]);
        platform.material = coverMaterial;
        platform.checkCollisions = true;           // <-- importante
        
        const support = BABYLON.MeshBuilder.CreateBox("support", { width: 0.5, height: 2.5, depth: 0.5 }, scene);
        support.position.set(pos[0], 1.25, pos[1]);
        support.material = blockMaterial;
        support.checkCollisions = true;             // <-- importante
    });
}

createBattleMap();

const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 60, height: 60 }, scene);
ground.position.y = 0;
ground.material = new BABYLON.StandardMaterial("groundMat", scene);
ground.material.diffuseTexture = new BABYLON.Texture("../texture/ciment_chao.jpg", scene);
ground.material.diffuseTexture.uScale = 15;
ground.material.diffuseTexture.vScale = 15;
ground.checkCollisions = true;                     // <-- importante

scene.onBeforeRenderObservable.add(() => {
    const dt = engine.getDeltaTime()/1000;

    if (keys.a) moveDir -= TURN_SPEED_KEY * dt;
    if (keys.d) moveDir += TURN_SPEED_KEY * dt;

    const moveForward = new BABYLON.Vector3(Math.sin(moveDir), 0, Math.cos(moveDir));

    if (isDeceleratingFromShift && currentSpeed > 10) {
        currentSpeed = Math.max(currentSpeed - 1, 10);
        if (currentSpeed <= 10) isDeceleratingFromShift = false;
    }

    if (keys.w && !isDeceleratingFromShift) {
        currentSpeed = Math.min(currentSpeed + ACCELERATION, maxSpeed);
    } else if (keys.s) {
        if (currentSpeed <= 0) {
            currentSpeed = Math.max(currentSpeed - ACCELERATION, -maxSpeed);
        } else {
            currentSpeed = Math.max(currentSpeed - (DECELERATION + 0.2), 0);
        }
    } else {
        if (currentSpeed > 0) currentSpeed = Math.max(currentSpeed - DECELERATION, 0);
        else if (currentSpeed < 0) currentSpeed = Math.min(currentSpeed + DECELERATION, 0);
    }
    
    if (Math.abs(currentSpeed) > 0.01) {
        const direction = currentSpeed < 0 ? moveForward.scale(-1) : moveForward;
        const movement = direction.scale(Math.abs(currentSpeed) * dt);

        sphere.moveWithCollisions(movement);
        // ====================================================

        if (Math.abs(currentSpeed) > 0.1) {
            sphere.rotation.x += (currentSpeed * dt) / RADIUS;
        }
    }

    sphere.rotation.y = moveDir;

    const aimForward = new BABYLON.Vector3(
        Math.sin(aimDir) * Math.cos(aimPitch),
        Math.sin(aimPitch),
        Math.cos(aimDir) * Math.cos(aimPitch)
    ).normalize();
    //
    const y0 = sphere.position.y + 1.4;
    const vx = aimForward.x * PROJECTILE_SPEED;
    const vy = aimForward.y * PROJECTILE_SPEED;
    const vz = aimForward.z * PROJECTILE_SPEED;
    const g = Math.abs(GRAVITY);
    const tHit = (vy + Math.sqrt(vy*vy + 2*g*y0)) / g;
    const hitX = sphere.position.x + vx * tHit;
    const hitZ = sphere.position.z + vz * tHit;
    //
    const proj = BABYLON.Vector3.Project(
        new BABYLON.Vector3(hitX, 0, hitZ),
        BABYLON.Matrix.Identity(),
        scene.getTransformMatrix(),
        camera.viewport.toGlobal(engine)
    );
    // Ajusta posição do crosshair na tela
    crosshair.left = proj.x - engine.getRenderWidth()/2;
    crosshair.top  = proj.y - engine.getRenderHeight()/2;
    // Ajusta posição da modelo3D em relação à sphere
    const rightOffset = new BABYLON.Vector3(
        Math.cos(aimDir) * 
        (RADIUS + 0.04), // <-- ajuste lateral
        0.5,                               // <-- ajuste vertical
        -Math.sin(aimDir) * (RADIUS + 0.5) // <-- ajuste profundidade
    );
    if (modelo3D) {
        // Atualiza posição do modelo3D para seguir a sphere
        modelo3D.position.x = sphere.position.x;
        modelo3D.position.z = sphere.position.z;
        modelo3D.position.y = sphere.position.y; // <-- ajuste vertical da modelo3D

        // Corrige a frente do modelo3D somando 180º à rotação Y
        modelo3D.rotation.y = Math.PI / 0.02 + Math.atan2(rightOffset.x, rightOffset.z);
    }
    // Atualiza miniGunMesh continuamente na mesma posição do spawn do bullet
    if (window.miniGunMesh) {
        const rightOffset = new BABYLON.Vector3(
            Math.cos(aimDir) * (RADIUS + 0.02),
            1,
            -Math.sin(aimDir) * (RADIUS + 0.02)
        );
        const miniGunPos = sphere.position.add(rightOffset);
        window.miniGunMesh.position.copyFrom(miniGunPos);
        // Faz o miniGun sempre apontar para a direção do crosshair
        const lookPoint = miniGunPos.add(aimForward.scale(10));
        window.miniGunMesh.lookAt(lookPoint);
    }

    // Aplica gravidade com moveWithCollisions
    velocityY += GRAVITY * dt;
    const verticalMovement = new BABYLON.Vector3(0, velocityY * dt, 0);
    sphere.moveWithCollisions(verticalMovement);
    
    // Verifica se está no chão com raycast partindo do centro da esfera
    const rayDown = new BABYLON.Ray(sphere.position, new BABYLON.Vector3(0, -1, 0), RADIUS + 0.15);
    const hit = scene.pickWithRay(rayDown, mesh => mesh !== sphere && mesh !== modelo3D && !mesh.name.includes("bullet"));
    
    if (hit.hit && hit.distance <= RADIUS + 0.02) {
        isGrounded = true;
        if (velocityY < 0) {
            velocityY = 0;
        }
    } else {
        isGrounded = false;
    }

    cooldown -= dt;
    if (isFiring && cooldown <= 0) {
        cooldown = 0.07;
        // Calcula posição de spawn do bullet normalmente
        const rightOffset = new BABYLON.Vector3(
            Math.cos(aimDir) * (RADIUS + 0.02),
            1,
            -Math.sin(aimDir) * (RADIUS + 0.02)
        );
        const spawn = sphere.position.add(rightOffset);
        // Faz o mesh miniGun seguir a posição do spawn do bullet
        if (window.miniGunMesh) {
            window.miniGunMesh.position.copyFrom(spawn);
        }
        const b = BABYLON.MeshBuilder.CreateSphere("bullet", { diameter: 0.12 }, scene);
        b.position.copyFrom(spawn);
        b.material = new BABYLON.StandardMaterial("", scene);
        b.material.emissiveColor = new BABYLON.Color3(1, 0.9, 0.3);
        bullets.push({ m: b, v: aimForward.scale(PROJECTILE_SPEED), t: 0, bounces: 0 });
    }

    for (let i = bullets.length - 1; i >= 0; i--) {
        const bu = bullets[i];
        bu.v.y += GRAVITY * 0.5 * dt;
        
        const velocity = bu.v.scale(dt);
        const ray = new BABYLON.Ray(bu.m.position, velocity.normalize(), velocity.length());
        const hit = scene.pickWithRay(ray, mesh => mesh !== sphere && mesh !== modelo3D && !mesh.name.includes("bullet"));
        
        if (hit.hit) {
            if (bu.bounces < MAX_BOUNCES) {
                const normal = hit.getNormal(true);
                const reflected = bu.v.subtract(normal.scale(2 * BABYLON.Vector3.Dot(bu.v, normal)));
                bu.v = reflected.scale(BOUNCE_DAMPING);
                bu.bounces++;
                bu.m.position.addInPlace(normal.scale(0.1));
            } else {
                bu.m.dispose();
                bullets.splice(i, 1);
            }
        } else {
            bu.m.position.addInPlace(velocity);
            bu.t += dt;
            
            if (bu.m.position.y <= 0) {
                if (bu.bounces < MAX_BOUNCES) {
                    bu.v.y = Math.abs(bu.v.y) * BOUNCE_DAMPING;
                    bu.m.position.y = 0.1;
                    bu.bounces++;
                } else {
                    bu.m.dispose();
                    bullets.splice(i, 1);
                }
            } else if (bu.t > 5) {
                bu.m.dispose();
                bullets.splice(i, 1);
            }
        }
    }

    const camOffset = cameraSwitched ? camOffsetSwitch : camOffsetDefault;

    camRot = BABYLON.Scalar.Lerp(camRot, aimDir + Math.PI, 0.1);
    const offset = BABYLON.Vector3.TransformCoordinates(camOffset, BABYLON.Matrix.RotationY(camRot));
    const target = sphere.position.clone().add(offset);
    camera.position = BABYLON.Vector3.Lerp(camera.position, target, 0.1);

    const camTarget = sphere.position.clone().add(
        new BABYLON.Vector3(
            Math.sin(aimDir) * Math.cos(aimPitch),
            Math.sin(aimPitch) + 1.2,
            Math.cos(aimDir) * Math.cos(aimPitch)
        )
    );
    camera.setTarget(camTarget);
});

engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>

</body>
</html>